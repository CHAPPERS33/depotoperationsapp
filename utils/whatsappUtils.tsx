
import React, { useState } from 'react';
import { MessageCircle, Copy, Check } from 'lucide-react';
import { Forecast, WorkSchedule, TeamMember, SubDepot, TimeslotAssignment, Round, TimeslotTemplate } from '../types';
import { getTimeslotCapacity } from './timeslotUtils'; // Ensure this util is available and correctly pathed

export const copyToClipboard = async (text: string): Promise<boolean> => {
  if (!navigator.clipboard) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.opacity = '0';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
      document.execCommand('copy');
      document.body.removeChild(textArea);
      return true;
    } catch (err) {
      console.error('Fallback: Oops, unable to copy', err);
      document.body.removeChild(textArea);
      return false;
    }
  }
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (err) {
    console.error('Async: Could not copy text: ', err);
    return false;
  }
};

export const shareToWhatsApp = (message: string): void => {
  const encodedMessage = encodeURIComponent(message);
  const whatsappUrl = `https://wa.me/?text=${encodedMessage}`;
  window.open(whatsappUrl, '_blank');
};

interface WhatsAppShareButtonProps {
  message: string;
  label?: string;
  className?: string;
}

export const WhatsAppShareButton: React.FC<WhatsAppShareButtonProps> = ({ message, label = "Share to WhatsApp", className = "" }) => {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    const success = await copyToClipboard(message);
    if (success) {
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } else {
      alert('Failed to copy message. Please try manually.');
    }
  };

  return (
    <div className={`flex gap-2 ${className}`}>
      <button
        onClick={() => shareToWhatsApp(message)}
        className="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg flex items-center gap-2 text-sm font-medium transition-colors"
        title="Open WhatsApp with pre-filled message"
      >
        <MessageCircle className="w-4 h-4" />
        {label}
      </button>
      <button
        onClick={handleCopy}
        className="bg-gray-500 hover:bg-gray-600 text-white px-3 py-2 rounded-lg flex items-center gap-1 text-sm font-medium transition-colors"
        title="Copy message to clipboard"
      >
        {copied ? (
          <><Check className="w-4 h-4" />Copied!</>
        ) : (
          <><Copy className="w-4 h-4" />Copy</>
        )}
      </button>
    </div>
  );
};


export const generateForecastWhatsAppMessage = (
  forecast: Forecast,
  allSubDepots: SubDepot[],
  depotOpenTime?: string
): string => {
  const forecastDate = new Date(forecast.forecast_for_date + 'T00:00:00Z'); 
  const formattedDate = forecastDate.toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' });
  
  let volumeText = '';
  if (forecast.volumes && forecast.volumes.length > 0) {
    volumeText = forecast.volumes
      .map(v => {
        const subDepotName = allSubDepots.find(sd => sd.id === v.sub_depot_id)?.name || `Sub Depot ${v.sub_depot_id}`;
        return `â€¢ ${subDepotName}: ${v.volume.toLocaleString()} parcels`;
      })
      .join('\n');
  } else if (forecast.total_volume) {
    volumeText = `â€¢ Total Volume (Overall): ${forecast.total_volume.toLocaleString()} parcels`;
  }

  const message = `ðŸ—“ï¸ *Forecast - ${formattedDate}* \n\n` +
                  `ðŸ“Š *Volume Forecast:*\n${volumeText || 'â€¢ No volumes specified'}\n` +
                  `${(forecast.volumes && forecast.volumes.length > 0 && forecast.total_volume) ? `â€¢ *Total: ${(forecast.total_volume || 0).toLocaleString()} parcels*` : ''}\n\n` +
                  `â° *Planned Shift: ${forecast.planned_shift_length || 'TBC'} hours*\n` +
                  `ðŸ­ *Depot Opens: ${depotOpenTime || 'TBC'}*\n\n` +
                  `${forecast.notes ? `ðŸ“ *Notes:* ${forecast.notes}` : ''}\n\n` +
                  `---\nGenerated by DUC Operations System`;
  return message;
};

export const generateTeamScheduleWhatsAppMessage = (
  schedules: WorkSchedule[],
  date: string, // YYYY-MM-DD
  allTeamMembers: TeamMember[],
  allSubDepots: SubDepot[],
  depotOpenTime?: string
): string => {
  const scheduleDate = new Date(date + 'T00:00:00Z');
  const formattedDate = scheduleDate.toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' });

  const formatScheduleEntry = (schedule: WorkSchedule) => {
    const member = allTeamMembers.find(tm => tm.id === schedule.team_member_id);
    const subDepot = allSubDepots.find(sd => sd.id === schedule.sub_depot_id);
    const timeRange = schedule.shift_start_time && schedule.shift_end_time 
                      ? `${schedule.shift_start_time}-${schedule.shift_end_time}` 
                      : schedule.scheduled_hours != null 
                        ? `${schedule.scheduled_hours}h` 
                        : 'N/A';
    const status = schedule.is_confirmed ? 'âœ…' : 'â³';
    let subDepotShortName = `Sub ${schedule.sub_depot_id}`;
    if (subDepot) {
        const nameParts = subDepot.name.split(' '); 
        if (nameParts.length >= 3 && !isNaN(parseInt(nameParts[2]))) {
            subDepotShortName = nameParts[2]; 
            if (subDepot.name.includes("Edmonton")) subDepotShortName = `E${subDepotShortName}`;
            else if (subDepot.name.includes("Barking")) subDepotShortName = `B${subDepotShortName}`;
        }
    }
    return `â€¢ ${member?.name || schedule.team_member_id} (${subDepotShortName}) - ${timeRange} ${status}`;
  };

  const sorters = schedules.filter(s => allTeamMembers.find(tm => tm.id === s.team_member_id)?.position === 'Sorter').sort((a,b) => (allTeamMembers.find(tm => tm.id === a.team_member_id)?.name || '').localeCompare(allTeamMembers.find(tm => tm.id === b.team_member_id)?.name || ''));
  const ducs = schedules.filter(s => allTeamMembers.find(tm => tm.id === s.team_member_id)?.position === 'DUC').sort((a,b) => (allTeamMembers.find(tm => tm.id === a.team_member_id)?.name || '').localeCompare(allTeamMembers.find(tm => tm.id === b.team_member_id)?.name || ''));
  const marshalls = schedules.filter(s => allTeamMembers.find(tm => tm.id === s.team_member_id)?.position === 'Marshall').sort((a,b) => (allTeamMembers.find(tm => tm.id === a.team_member_id)?.name || '').localeCompare(allTeamMembers.find(tm => tm.id === b.team_member_id)?.name || ''));

  const totalStaff = schedules.length;
  const totalHours = schedules.reduce((sum, s) => sum + (s.actual_hours ?? s.scheduled_hours ?? 0), 0);

  let message = `ðŸ‘¥ *Team Schedule - ${formattedDate}*\n\nðŸ­ *Depot Opens: ${depotOpenTime || 'TBC'}*\n\n`;
  if (sorters.length > 0) message += `ðŸ”„ *Sorters (${sorters.length}):*\n${sorters.map(formatScheduleEntry).join('\n')}\n\n`;
  if (ducs.length > 0) message += `ðŸŽ¯ *DUCs (${ducs.length}):*\n${ducs.map(formatScheduleEntry).join('\n')}\n\n`;
  if (marshalls.length > 0) message += `ðŸ“‹ *Marshalls (${marshalls.length}):*\n${marshalls.map(formatScheduleEntry).join('\n')}\n\n`;
  if (schedules.length === 0) message += `_No staff scheduled for this date._\n\n`;
  message += `*Total Staff: ${totalStaff} | Total Hours: ${totalHours.toFixed(1)}*\n\nLegend: âœ… Confirmed | â³ Pending\n\n---\nGenerated by DUC Operations System`;
  return message;
};

export const generateTimeslotWhatsAppMessage = (
  date: string, // YYYY-MM-DD
  assignments: TimeslotAssignment[],
  subDepots: SubDepot[],
  rounds: Round[],
  timeslotTemplates: TimeslotTemplate[], 
  subDepotIdInput?: number
): string => {
  const formattedDate = new Date(date + 'T00:00:00Z').toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' });
  let title = `ðŸ“… *Timeslots - ${formattedDate}*\n\n`;
  let subDepotsToProcess = subDepots;

  if (subDepotIdInput) {
    const subDepot = subDepots.find(sd => sd.id === subDepotIdInput);
    if (subDepot) {
      title = `ðŸ“… *${subDepot.name} Timeslots - ${formattedDate}*\n\n`;
      subDepotsToProcess = [subDepot];
    } else {
      return "Error: Sub-Depot not found.";
    }
  }

  let message = title;
  subDepotsToProcess.forEach(currentSubDepot => {
    if (!currentSubDepot) return;
    const subDepotAssignments = assignments.filter(a => a.sub_depot_id === currentSubDepot.id);
    if (subDepotAssignments.length === 0 && subDepotIdInput) { 
        message += `_No timeslots assigned for ${currentSubDepot.name} on this date._\n\n`;
        return;
    }
    if (subDepotAssignments.length === 0) return; 

    message += `ðŸ­ *${currentSubDepot.name}*\n`;
    const timeslotGroups = subDepotAssignments.reduce((acc, assignment) => {
      if (!acc[assignment.timeslot]) acc[assignment.timeslot] = [];
      acc[assignment.timeslot].push(assignment);
      return acc;
    }, {} as Record<string, TimeslotAssignment[]>);

    Object.entries(timeslotGroups)
      .sort(([a], [b]) => a.localeCompare(b))
      .forEach(([timeslot, slotAssignments]) => {
        const capacity = getTimeslotCapacity(date, currentSubDepot.id, timeslot, assignments, timeslotTemplates, subDepots);
        const warningIcon = capacity.used > capacity.max ? 'âš ï¸ ' : '';
        message += `â° *${timeslot}* (${capacity.used}/${capacity.max}) ${warningIcon}\n`;
        slotAssignments.forEach(assignment => {
          const round = rounds.find(r => r.id === assignment.round_id);
          message += `   â€¢ Round ${assignment.round_id} (Drop ${round?.drop_number || 'N/A'})\n`;
        });
        message += '\n';
      });
  });

  if (message === title && !subDepotIdInput) { 
    message += "_No timeslots assigned for any sub-depots on this date._\n\n";
  } else if (message === title && subDepotIdInput) { 
    
  }
  
  message += `---\nGenerated by DUC Operations System`;
  return message;
};
